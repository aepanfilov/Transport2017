using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Транспорт2017
{
    public class МатрицаКорреспонденций
    {
        private СписокПутейКорреспонденций[,] матрица;//2 мерный массив (колОстановок, колОстановок)
        //    //!!! номера строк столбцов соответствуют кодам остановок-1
        //    //!!! коды остановок должны быть сплошными, начиная с 1

        public event EventHandler<IntEventArg> СтрокаОтработана;

        public int Размерность { get { return матрица.GetLength(0); } }

        public List<ПутьКорреспонденции> СписокПутей(int остОт, int остДо)
        { return матрица[остОт - 1, остДо - 1].пути; }

        public МатрицаКорреспонденций(int КолОстановок)
        {
            //выделение памяти под матрицу
            матрица = new СписокПутейКорреспонденций[КолОстановок, КолОстановок];
            for (int i = 0; i < КолОстановок; i++)
                for (int j = 0; j < КолОстановок; j++)
                    матрица[i, j] = new СписокПутейКорреспонденций();
        }
        public void Инициализация(Маршрут[] масМаршрутов)
        {
            int count, ostFrom, ostTo;
            ПутьКорреспонденции новПуть;
            double sumcrit;

            for (int i_marsh = 0; i_marsh < масМаршрутов.Length; i_marsh++)
            {
                Маршрут marsh = масМаршрутов[i_marsh];
                count = marsh.КоличОстановок - 1;
                int[] масКодОст = marsh.КодыОстановок;
                for (int i = 0; i < count; i++)
                {
                    ostFrom = масКодОст[i] - 1;
                    sumcrit = 0;
                    for (int j = i + 1; j <= count; j++)
                    {
                        ostTo = масКодОст[j] - 1;
                        sumcrit += marsh.ДлинаПерегона(j);

                        новПуть = new ПутьКорреспонденции
                        {
                            КодМаршрута = marsh.Код,
                            Критерий = sumcrit,
                            ТипПутиКорресп = ТипПутиКорреспонденцииEnum.безПересадки
                        };

                        матрица[ostFrom, ostTo].пути.Add(новПуть);

                        if (матрица[ostFrom, ostTo].ЛучшийКритерий > sumcrit)
                            матрица[ostFrom, ostTo].ЛучшийКритерий = sumcrit;
                    }
                }
            }
        }
        public void УчетПересадок(Маршрут[] масМарш)
        {
            int countOst = матрица.GetLength(0);//Размерность - 1;
            //цикл по элементам матрицы корреспонденции - поиск недостижимой пары остановок
            for (int i_matr = 0; i_matr < countOst; i_matr++)
            {
                for (int j_matr = 0; j_matr < countOst; j_matr++)
                {
                    if (i_matr == j_matr)
                        continue;
                    if (матрица[i_matr, j_matr].ЛучшийКритерий != ПутьКорреспонденции.БЕСКОНЕЧНОСТЬ)
                        if (матрица[i_matr, j_matr].пути[0].ТипПутиКорресп == ТипПутиКорреспонденцииEnum.безПересадки)
                            continue;
                    //найдена недостижимая пара остановок (из i_matr в j_matr)
                    // поиск маршрута начала (через i_matr)
                    for (int i_mrsh = 0; i_mrsh < масМарш.Length; i_mrsh++)
                    {
                        int[] масКодОст = масМарш[i_mrsh].КодыОстановок;
                        for (int i_ost = 0; i_ost < масКодОст.Length; i_ost++)
                        {
                            int code_i_ost = масКодОст[i_ost] - 1; //коды остановок идут с 1, поэтому -1
                            if (code_i_ost == i_matr)
                            {
                                //маршрут начала найден (i_mrsh)
                                //перебор по остановкам после i_ost - можно с них добраться до j_matr
                                for (int j_ost = i_ost + 1; j_ost < масКодОст.Length; j_ost++)
                                {
                                    int code_j_ost = масКодОст[j_ost] - 1;
                                    if (i_ost == j_ost || матрица[code_j_ost, j_matr].ЛучшийКритерий == ПутьКорреспонденции.БЕСКОНЕЧНОСТЬ) continue;
                                    if (матрица[code_j_ost, j_matr].пути[0].ТипПутиКорресп == ТипПутиКорреспонденцииEnum.сПересадкой) continue;
                                    //найден маршрут с пересадкой в code_j_ost

                                    //формирование маршрута с пересадкой
                                    // перебор всех беспересадочных путей из ячейки (code_j_ost, j_matr)
                                    foreach (ПутьКорреспонденции путь2 in матрица[code_j_ost, j_matr].пути)
                                    {
                                        if (путь2.ТипПутиКорресп == ТипПутиКорреспонденцииEnum.сПересадкой)
                                            break;
                                        //найти критерий до остановки пересадки - перебор всех беспересадочных путей из ячейки (code_i_ost, code_j_ost)
                                        double crit_i = 0;
                                        int codeMarsh = масМарш[i_mrsh].Код;
                                        foreach (ПутьКорреспонденции путь1 in матрица[code_i_ost, code_j_ost].пути)
                                        {
                                            if (путь1.ТипПутиКорресп == ТипПутиКорреспонденцииEnum.безПересадки &&
                                                путь1.КодМаршрута == codeMarsh)
                                            {
                                                crit_i = путь1.Критерий;
                                                break;
                                            }
                                        }
                                        //добавить новый маршрут с пересадкой
                                        ПутьКорреспонденции новПуть = new ПутьКорреспонденции
                                        {
                                            КодМаршрута = codeMarsh,
                                            КодОстановкиПересадки = code_j_ost + 1,
                                            КодМаршрутаПослеПересадки = путь2.КодМаршрута,
                                            Критерий = crit_i + путь2.Критерий,
                                            ТипПутиКорресп = ТипПутиКорреспонденцииEnum.сПересадкой
                                        };
                                        матрица[i_matr, j_matr].пути.Add(новПуть);

                                        if (матрица[i_matr, j_matr].ЛучшийКритерий > новПуть.Критерий)
                                            матрица[i_matr, j_matr].ЛучшийКритерий = новПуть.Критерий;
                                    }
                                    break;//после первой остановки с пересадкой - перейти к следующему маршруту
                                }
                                break;//маршрут с i_ost = i_matr проверен
                            }
                        }
                    }
                }
                СтрокаОтработана?.Invoke(this, new IntEventArg(i_matr));
            }
        }
        public void СортироватьПути()// отсортировать пути по возрастанию критерия
        {
            foreach (СписокПутейКорреспонденций СписокПутей in матрица)
                СписокПутей.пути.Sort();
        }
        public string СписокМаршрутов(int остОт, int остДо)
        {
            StringBuilder res = new StringBuilder();
            foreach (ПутьКорреспонденции путь in матрица[остОт, остДо].пути)
                if (путь.ТипПутиКорресп == ТипПутиКорреспонденцииEnum.безПересадки)
                    res.AppendFormat("{0} ({1}), ", путь.КодМаршрута, путь.Критерий);
                else
                    res.AppendFormat("[{0}, {1}; {2}] ({3}), ", путь.КодМаршрута, путь.КодМаршрутаПослеПересадки, путь.КодОстановкиПересадки, путь.Критерий);
            return res.ToString();
        }
        public void ДобавитьПуть(int ostFrom, int ostTo, ПутьКорреспонденции новПуть)
        {
            ostFrom--;
            ostTo--;
            матрица[ostFrom, ostTo].пути.Add(новПуть);
            if (матрица[ostFrom, ostTo].ЛучшийКритерий > новПуть.Критерий)
                матрица[ostFrom, ostTo].ЛучшийКритерий = новПуть.Критерий;
        }
    }
}